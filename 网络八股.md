## 网络模型

### TCP/IP四层模型？

应用层：通过各种协议实现网络应用程序的功能，如HTTP、HTTPS、CDN、DNS、FTP

传输层：通过TCP和UDP实现端到端的通信

网络层：通过IP协议实现数据包的路由和转发

网络接口层：负责计算机和网络硬件之间的数据传输

### OSI七层模型

自底向上：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

物理层：描述物理层面的传输，光纤和电缆

数据链路层：可以认为是MAC层面相邻节点的传输

网络层：IP层面的寻址和路由

传输层：TCP和UDP层面的传输

会话层：负责会话状态的保持、管理和同步

表示层：一些数据的转化、压缩和编码

应用层：http之类的协议的交互转化

## 应用层

### 应用层有哪些协议？

HTTP（80）、HTTPS（443）、CDN、DNS（53）、FTP 都是应用层协议

### CDN

CDN（Content Delivery Network）是一个由多个地理位置分散的服务器节点组成的分布式网络架构，用于加速互联网内容的分发。

当用户请求内容时，CDN 会根据用户的地理位置，将请求转发到最近的缓存服务器上。这样可以减少数据传输的延迟，提高用户访问速度，同时减轻源服务器的负载。

CDN 通常用于加速静态内容（如图片、视频、静态页面等）的访问，提高网站的性能和用户体验。

### HTTP报文有哪些部分？

**请求报文：**

- 请求行：包含请求方法、请求目标（URL或URI）和HTTP协议版本。
- 请求头部：包含关于请求的附加信息，如Host、User-Agent、Content-Type等。
- 空行：请求头部和请求体之间用空行分隔。
- 请求体：可选，包含请求的数据，通常用于POST请求等需要传输数据的情况。

**响应报文：**

- 状态行：包含HTTP协议版本、状态码和状态信息。
- 响应头部：包含关于响应的附加信息，如Content-Type、Content-Length等。
- 空行：响应头部和响应体之间用空行分隔。
- 响应体：包含响应的数据，通常是服务器返回的HTML、JSON等内容。

### HTTP常用的状态码？

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202407291629592.webp)

HTTP 状态码分为 5 大类 

- 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 
- 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
- 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。
- 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 
- 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 

其中常见的具体状态码有： 

200：请求成功； 

301：永久重定向；302：临时重定向； 

404：无法找到此页面；405：**请求的方法类型**不支持； 

500：服务器内部出错。

### HTTP返回状态301 302分别是什么？

3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 

- 「301 Moved Permanently」表示**永久重定向**，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 
- 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 

301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。

### http 502和 504 的区别？

- 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 
- 504 Gateway Time-out：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。 

举一个例子，假设 nginx 是代理服务器，收到客户端的请求后，将请求转发到后端服务器（tomcat 等）。 当nginx收到了无效的响应时，就返回502。 当nginx超过自己配置的超时时间，还没有收到请求时，就返回504错误。

### HTTP层请求的类型有哪些？

GET：用于请求获取指定资源，通常用于获取数据。 

POST：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。 

PUT：用于向服务器更新指定资源，通常用于更新已存在的资源。 

DELETE：用于请求服务器删除指定资源。 

HEAD：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。

### GET和POST的使用场景，有哪些区别？ 

根据 RFC 规范，**GET 的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET 请求的**参数位置一般是写在 URL** 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的**长度有限制**（HTTP协议本身对 URL长度并没有做任何规定）。 比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。

根据 RFC 规范，**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。 比如，你在我文章底部，敲入了留言后点击「提交」（暗示你们留言），浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。

如果从 RFC 规范定义的语义来看：

- GET 方法就是**安全且幂等**的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存**，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。 

- POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等的**。所以，**浏览器一般不会缓存 POST 请求**，也不能把 POST 请求保存为书签。

### HTTP是什么？

HTTP是超文本传输协议，也就是**H**yper**T**ext **T**ransfer **P**rotocol。

详细介绍超文本传输协议

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

### http1.0，1.1，2, 3区别

#### HTTP/1.0

1. **请求/响应模型**: 每个请求/响应对都建立一个单独的TCP连接，完成后立即关闭。这种方式导致了大量的开销，特别是在建立和关闭连接时。

#### HTTP/1.1

1. **持久连接**: 默认使用持久连接（也称为长连接），即在一个TCP连接上可以进行多个请求/响应对，减少了连接建立和关闭的开销。
2. **管道化**: 允许在同一个TCP连接上并行发送多个请求，而不必等待前一个请求的响应

#### HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈：

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

#### HTTP/2

那 HTTP/2 相比 HTTP/1.1 性能上的改进：

- 头部压缩
- 二进制格式
- 并发传输
- 服务器主动推送资源

*1. 头部压缩*

HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。

这就是所谓的 `HPACK` 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了。

*2. 二进制格式*

HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式**

*3. 并发传输*

我们都知道 HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了**队头阻塞**的问题。

而 HTTP/2引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。

**针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应**。

*4、服务器推送*

HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以**主动**向客户端发送消息。

**HTTP/2 有什么缺陷？**

HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。

**HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。**

#### HTTP/3

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

当然，HTTP/3 不仅仅只是简单将传输协议替换成了 UDP，还基于 UDP 协议在「应用层」实现了 **QUIC 协议**，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。

QUIC 协议的优点有很多，这里举例几个，比如：

- 无队头阻塞；
- 更快的连接建立；
- 连接迁移；

*1、无队头阻塞*

QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。

QUIC 有自己的一套机制可以保证传输的可靠性的。**当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题**。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。

所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。

*2、更快的连接建立*

对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。

HTTP/3 在传输数据前虽然需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。

但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协

*3、连接迁移*

基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。

那么**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接**。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。

而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

### HTTP和HTTPs

#### HTTP 与 HTTPS 有哪些区别？

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

#### HTTPS 解决了 HTTP 的哪些问题？

HTTP 由于是明文传输，所以安全上存在以下三个风险：

- **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
- **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
- **冒充风险**，比如冒充淘宝网站，用户钱容易没。

HTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议，可以很好的解决了上述的风险：

- **信息加密**：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
- **身份证书**：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。

#### HTTPS 是如何解决上面的三个风险的？

- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

#### HTTPS是如何建立连接的？其间交互了什么？

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。

TLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA和ECDHE

基于 RSA 算法的 TLS 握手过程比较容易理解，所以这里先用这个给大家展示 TLS 握手过程，如下图：

![image-20240427182715142](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404271827760.png)

TLS 协议建立的详细流程：

*1. ClientHello*

首先，由客户端向服务器发起加密通信请求，也就是 `ClientHello` 请求。

在这一步，客户端主要向服务器发送以下信息：

（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

*2. SeverHello，Server Certificate， ServerHello*Done

服务器收到客户端请求后，向客户端发出响应，也就是 `SeverHello`。服务器回应的内容有如下内容：

（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（`Server Random`），也是后面用于生产「会话秘钥」条件之一。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

*3.Client Key Exchange， Change Cipher Spec，Client Finished*

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。

**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

*4. Change Cipher Spec，Server Finished*

服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

然后，向客户端发送最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

#### HTTPS 的应用数据是如何保证完整性的？

TLS 在实现上分为**握手协议**和**记录协议**两层：

- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：

![image-20240518145540194](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181455762.png)

具体过程如下：

- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。
- 接下来，经过压缩的片段会被**加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。

#### HTTPS RSA握手解析

**使用 RSA 密钥协商算法的最大问题是不支持前向保密**。

前向保密（Forward Secrecy，简称FS）是一种加密协议属性，旨在保护过去的通信内容，即使未来密钥泄露，也无法解密先前的会话数据。这一特性主要通过使用临时会话密钥来实现。前向保密在保护数据隐私方面起着至关重要的作用，特别是在应对潜在的密钥泄露和长期存储的加密数据被解密的风险时。

因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法

#### HTTPS ECDHE握手解析

HTTPS 常用的密钥交换算法有两种，分别是 RSA 和 ECDHE 算法。

其中，RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法具有前向安全，所以被广泛使用。

#### 离散对数

![image-20240518153943370](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181539854.png)

上图的，底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。

**特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。**

#### DH算法

认识了离散对数，我们来看看 DH 算法是如何密钥交换的。

现假设小红和小明约定使用 DH 算法来交换密钥，那么基于离散对数，小红和小明需要先确定模数和底数作为算法的参数，这两个参数是公开的，用 P 和 G 来代称。

然后小红和小明各自生成一个随机整数作为**私钥**，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。

现在小红和小明双方都有了 P 和 G 以及各自的私钥，于是就可以计算出**公钥**：

- 小红的公钥记作 A，A = G ^ a ( mod P )；
- 小明的公钥记作 B，B = G ^ b ( mod P )；

A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是非常困难的，至少在现有计算机的计算能力是无法破解的，如果量子计算机出来了，那就有可能被破解，当然如果量子计算机真的出来了，那么密钥协商算法就要做大的升级了。

双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。

然后小红执行运算： B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算： A ^ b ( mod P )，得到的结果也是 K。

![image-20240518154320130](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181543496.png)

这个 K 就是小红和小明之间用的**对称加密密钥**，可以作为会话密钥使用。

可以看到，整个密钥协商过程中，小红和小明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B 是公钥，而 a、b 是双方各自保管的私钥，黑客无法获取这 2 个私钥，因此黑客只能从公开的 P、G、A、B 入手，计算出离散对数（私钥）。

前面也多次强调， 根据离散对数的原理，如果 P 是一个大数，在现有的计算机的计算能力是很难破解出 私钥 a、b 的，破解不出私钥，也就无法计算出会话密钥，因此 DH 密钥交换是安全的。

#### DHE 算法

根据私钥生成的方式，DH 算法分为两种实现：

- static DH 算法，这个是已经被废弃了；
- DHE 算法，现在常用的；

static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。

于是，DH 交换密钥时就只有客户端的公钥是变化，而服务端公钥是不变的，那么随着时间延长，黑客就会截获海量的密钥协商过程的数据，因为密钥协商的过程有些数据是公开的，黑客就可以依据这些数据暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解，所以 **static DH 算法不具备前向安全性**。

既然固定一方的私钥有被破解的风险，那么干脆就让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。

所以，即使有个牛逼的黑客破解了某一次通信过程的私钥，其他通信过程的私钥仍然是安全的，因为**每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」**。

------

#### ECDHE 算法

DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— **ECDHE 算法**。

ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。

小红和小明使用 ECDHE 密钥交换算法的过程：

- 双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；
- 双方各自随机生成一个随机数作为**私钥d**，并与基点 G相乘得到**公钥Q**（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；
- 双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此**双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥**。

这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）

#### ECDHE的握手过程

**使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据**，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。

所以，**ECDHE 相比 RSA 握手过程省去了一个消息往返的时间**，这个有点「抢跑」的意思，它被称为是「*TLS False Start*」，跟「*TCP Fast Open*」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。

##### 第一次握手 Client Hello

客户端首先会发一个「**Client Hello**」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的**随机数（\*Client Random\*）**

![image-20240518162225948](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181622037.png)

##### 第二次握手 Server Hello，Server Certificate，Server Key exchange， Server Hello done

服务端收到客户端的「打招呼」，同样也要回礼，会返回「**Server Hello**」消息，消息面有服务器确认的 TLS 版本号，也给出了一个**随机数（\*Server Random\*）**，然后从客户端的密码套件列表选择了一个合适的密码套件。

![image-20240518162236532](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181622491.png)

接着，服务端为了证明自己的身份，发送「**Certificate**」消息，会把证书也发给客户端。

![image-20240518162248898](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181622948.png)

这一步就和 RSA 握手过程有很大的区别了，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「**Server Key Exchange**」消息。

这个过程服务器做了三件事：

- 选择了**名为 x25519 的椭圆曲线**，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；
- 生成随机数作为服务端椭圆曲线的私钥，保留到本地；
- 根据基点 G 和私钥计算出**服务端的椭圆曲线公钥**，这个会公开给客户端。

为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用 RSA 签名算法给服务端的椭圆曲线公钥做个签名。

随后，就是「**Server Hello Done**」消息，服务端跟客户端表明：“这些就是我提供的信息，打招呼完毕”。

![image-20240518162936339](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181629831.png)

至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：**Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥**，这几个信息很重要，是后续生成会话密钥的材料。

其中Server Certificate中是对服务器的长期公钥通过CA的私钥做的数字签名，Server Key Exchange是用服务器的长期私钥对临时公钥做的数字签名，客户端通过CA的公钥解密获得服务器的长期公钥，在通过服务器的长期公钥解密获得服务器的临时公钥

##### 第三次握手Client Key exchange，Client Cipher Spec， Client Finished

客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书的过程会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。

客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成**客户端的椭圆曲线公钥**，然后用「**Client Key Exchange**」消息发给服务端。

![image-20240518163259224](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181633111.png)

至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，**但实际应用中，x 还不是最终的会话密钥**。

还记得 TLS 握手阶段，客户端和服务端都会生成了一个随机数传递给对方吗？

**最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的**。

之所以这么麻烦，是因为 TLS 设计者不信任客户端或服务器「伪随机数」的可靠性，为了保证真正的完全随机，把三个不可靠的随机数混合起来，那么「随机」的程度就非常高了，足够让黑客计算不出最终的会话密钥，安全性更高。

算好会话密钥后，客户端会发一个「**Change Cipher Spec**」消息，告诉服务端后续改用对称算法加密通信。

![image-20240518163905874](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405181639393.png)

接着，客户端会发「**Encrypted Handshake Message**」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。

##### TLS 第四次握手Server Cipher Spec，Server Finished

最后，服务端也会有一个同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了

#### HTTPS 一定安全可靠吗？

客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409251452407.png)

从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。 

但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。 

中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409251454578.png)

**所以，HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。**

#### 为什么抓包工具可以获取https的数据？

很多抓包工具 之所以可以明文看到 HTTPS 数据，**工作原理与中间人一致的。**

使用抓包工具进行 HTTPS 抓包的时候，需要在客户端**安装 Fiddler 的根证书**，这里实际上起认证中心（CA）的作用。 抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

#### 如何避免被中间人抓取数据？

我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样HTTPS数据就不会被中间人截取到了

也可以使用**双向认证**

一般来说https是单向认证，客户端只会认证服务器，服务器不会验证客户端，启用了双向认证后，中间人无法在服务器植入证书，那么就会认证失败

### 长连接和短连接的区别

#### 1. 短连接（Short Connection）

**定义**： 短连接是指客户端和服务器之间**每次通信都会建立一次新的连接**，数据传输完成后立即关闭连接。HTTP 1.0 默认使用短连接。

**工作流程**：

1. 客户端向服务器发起连接请求。
2. 服务器接受连接并进行数据传输。
3. 数据传输完成后，双方关闭连接。

**优点**：

- **资源占用少**：连接在数据传输完成后立即关闭，不会长时间占用服务器资源。
- **简单易实现**：每次请求都是独立的，不需要管理连接状态。

**缺点**：

- **连接开销大**：每次请求都需要建立和关闭连接，增加了网络延迟和服务器的负载。
- **效率低**：频繁建立和关闭连接，会浪费大量的系统资源，特别是在高频率的请求下。

**适用场景**：

- **低频请求**：适用于请求频率较低的场景，例如静态网页的访问。
- **短时间交互**：一次性数据交换量小、交互时间短的场景。

#### 2. 长连接（Long Connection）

**定义**： 长连接是指客户端和服务器之间建立的连接在数据传输完成后不会立即关闭，**而是保持一段时间**，以便后续的数据传输可以复用该连接。HTTP 1.1 默认使用长连接，通过在请求头中加入 `Connection: keep-alive` 来实现。

**工作流程**：

1. 客户端向服务器发起连接请求。
2. 服务器接受连接并进行数据传输。
3. 数据传输完成后，连接保持打开状态，等待后续的请求。
4. 在一定时间内，客户端可以复用该连接进行多次数据传输。
5. 当连接闲置超过一定时间后，服务器或客户端关闭连接。

**优点**：

- **减少连接开销**：复用连接减少了频繁建立和关闭连接的开销，提高了数据传输效率。
- **提升性能**：在高频率请求的场景下，长连接可以显著提升系统的响应速度和性能。

**缺点**：

- **资源占用多**：长时间保持连接会占用服务器资源，连接过多可能导致服务器压力增大。
- **复杂性增加**：需要管理连接的状态和超时机制，增加了实现的复杂性。

**适用场景**：

- **高频请求**：适用于请求频率较高的场景，例如动态网页、API接口等。
- **长时间交互**：需要长时间保持连接的场景，例如在线聊天、流媒体传输等。

### Keep-Alive和keepalive的区别

HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。

TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。

### HTTP进行TCP连接之后，在什么情况下会中断

- 当服务端或者客户端执行 close 系统调用的时候，会发送FIN报文，就会进行四次挥手的过程 
- 当发送方发送了数据之后，接收方超过一段时间没有响应ACK报文，发送方重传数据达到最大次数的时候，就会断开TCP连接 
- 当HTTP长时间没有进行请求和响应的时候，超过一定的时间，就会释放连接（TCP的Keepalive）

### DNS的端口是多少？

默认端口号是53，应用层协议，UDP传输，每次内容不超过512字节【因为非局域网下的MTU为576字节，IP头部最大为60字节，UDP头部为8字节，所有数据包不超过576 - 60 - 8 = 508，所以512是一个综合考虑的结果】

### DNS的底层使用TCP还是UDP？

DNS 基于UDP协议实现，DNS使用UDP协议进行域名解析和数据传输。因为基于UDP实现DNS能够提供低延迟、简单快速、轻量级的特性，更适合DNS这种需要快速响应的域名解析服务。 

- 低延迟： UDP是一种无连接的协议，不需要在数据传输前建立连接，因此可以减少传输时延，适合DNS这种需要快速响应的应用场景。 
- 简单快速： UDP相比于TCP更简单，没有TCP的连接管理和流量控制机制，传输效率更高，适合DNS这种需要快速传输数据的场景。 
- 轻量级：UDP头部较小，占用较少的网络资源，对于小型请求和响应来说更加轻量级，适合DNS这种频繁且短小的数据交换。 

尽管 UDP 存在丢包和数据包损坏的风险，但在 DNS 的设计中，这些风险是可以被容忍的。DNS 使用了一些机制来提高可靠性，例如查询超时重传、请求重试、缓存等，以确保数据传输的可靠性和正确性。

### DNS负载均衡

DNS负载均衡技术的实现原理是在DNS服务器中为**同一个主机名配置多个IP地址**，在应答DNS查询时，**DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果**，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。

最早的负载均衡技术是通过DNS来实现的，在DNS中为多个地址配置同一个名字，因而查询这个名字的客户机将得到其中一个地址，从而使得不同的客户访问不同的服务器，达到负载均衡的目的。

DNS负载均衡是一种简单而有效的方法，但是它不能区分服务器的差异，也不能反映服务器的当前运行状态。

### 为什么区域传送用TCP协议？

因为TCP协议可靠性好啊！

你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？所以用TCP协议比较好！

> DNS区域传送（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据，目的是为了做冗余备份，防止主服务器出现故障时 dns 解析不可用。

### HTTP到底是不是无状态的？

HTTP**是无状态的**，这意味着每个请求都是独立的，服务器不会在多个请求之间保留关于客户端状态的信息。在每个HTTP请求中，服务器不会记住之前的请求或会话状态，因此每个请求都是相互独立的。 

虽然HTTP本身是无状态的，但可以通过**一些机制来实现状态保持**，其中最常见的方式是使用**Cookie和Session来跟踪用户状态**。通过在客户端存储会话信息或状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能。

### 携带Cookie的HTTP请求是有状态还是无状态的？Cookie是HTTP协议簇的一部分，那为什么还说HTTP是无状态的？ 

携带Cookie的HTTP请求实际上是可以在一定程度上实现状态保持的，因为Cookie是用来在客户端存储会话信息和状态信息的一种机制。当浏览器发送包含Cookie的HTTP请求时，服务器可以通过读取这些Cookie来识别用户、管理会话状态以及保持特定的用户状态。因此，可以说即使HTTP本身是无状态的协议，但通过Cookie的使用可以实现一定程度的状态保持功能。 

HTTP被描述为“无状态”的主要原因是每个HTTP请求都是独立的，服务器并不保存关于客户端的状态信息，每个请求都需要提供足够的信息来理解请求的意图。这样的设计使得Web系统更具有规模化和简单性，但也导致了一些挑战，比如需要额外的机制来处理用户状态和会话管理。 

虽然Cookie是HTTP协议簇的一部分，但是HTTP协议在设计初衷上仍然保持无状态特性，即每个请求都是相互独立的。使用Cookie只是在无状态协议下的一种补充机制，用于在客户端存储状态信息以实现状态保持。

### cookie和session有什么区别？

Cookie和Session都是Web开发中用于跟踪用户状态的技术，但它们在存储位置、数据容量、安全性以及生命周期等方面存在显著差异：

**存储位置：**Cookie的数据存储在客户端（通常是浏览器）。当浏览器向服务器发送请求时，会自动附带Cookie中的数据。Session的数据存储在服务器端。服务器为每个用户分配一个唯一的Session ID，这个ID通常通过Cookie或URL重写的方式发送给客户端，客户端后续的请求会带上这个Session ID，服务器根据ID查找对应的Session数据。 

**数据容量：**单个Cookie的大小限制通常在4KB左右，而且大多数浏览器对每个域名的总Cookie数量也有限制。由于Session存储在服务器上，理论上不受数据大小的限制，主要受限于服务器的内存大小。 

**安全性：**Cookie相对不安全，因为数据存储在客户端，容易受到XSS（跨站脚本攻击）的威胁。不过，可以通过设置HttpOnly属性来防止JavaScript访问，减少XSS攻击的风险，但仍然可能受到CSRF（跨站请求伪造）的攻击。Session通常认为比Cookie更安全，因为敏感数据存储在服务器端。但仍然需要防范Session劫持（通过获取他人的Session ID）和会话固定攻击。

**生命周期：**Cookie可以设置过期时间，过期后自动删除。也可以设置为会话Cookie，即浏览器关闭时自动删除。Session在默认情况下，当用户关闭浏览器时，Session结束。但服务器也可以设置Session的超时时间，超过这个时间未活动，Session也会失效。 

**性能：**使用Cookie时，因为数据随每个请求发送到服务器，可能会影响网络传输效率，尤其是在Cookie数据较大时。使用Session时，因为数据存储在服务器端，每次请求都需要查询服务器上的Session数据，这可能会增加服务器的负载，特别是在高并发场景下。

### Cookie，session，token的区别

cookie存储在浏览器（客户端），生命周期由服务器设置

session存储在服务器，生命周期由服务器设置，通常比cookie更安全，客户端通过Cookie（通常是Session ID）来表示会话

token存储在客户端，是一个加密令牌，生命周期由服务器设置，可以跨多个会话使用

简单来说，cookie和session适合单次会话的认证和状态管理，token适合跨会话的认证和状态管理

### 如果客户端禁用了cookie，session还能用吗？

默认情况下禁用 Cookie 后，Session 是无法正常使用的，因为大多数 Web 服务器都是依赖于 Cookie 来传递 Session 的会话 ID 的。 

客户端浏览器禁用 Cookie 时，服务器将无法把会话 ID 发送给客户端，客户端也无法在后续请求中携带会话 ID 返回给服务器，从而导致服务器无法识别用户会话。

**URL重写：**每当服务器响应需要保持状态的请求时，将Session ID附加到URL中作为参数。例如，原本的链接http://example.com/page变为http://example.com/page;jsessionid=XXXXXX，服务器端需要相应地解析 URL 来获取 Session ID，并维护用户的会话状态。这种方式的缺点是URL变得不那么整洁，且如果用户通过电子邮件或其他方式分享了这样的链接，可能导致Session ID的意外泄露。

### JWT Token

token如JWT其实就是一个加密令牌，服务器通过一定的方式将**用户信息**加密生产一个JWT Token，后续客户端带着这个token来访问服务器，服务器可以解密获得对应的用用户信息，这样就能进行身份和权限的验证

## 传输层

### TCP基本认识

我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。

![image-20240517161358207](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171614421.png)

**序列号**：在建立连接时由计算机生成的**随机数**作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

**确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

**控制位：**

- *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初	建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
- *RST*：该位为 `1` 时，表示 TCP **连接中出现异常必须强制断开连接**。
- *SYN*：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：该位为 `1` 时，表示今后不会再有数据发送，**希望断开连接**。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。
- *PSH*：发送数据的应用通知TCP该发送的数据立即发出；PSH控制位告诉接收端该数据要立即推送给接收信息的应用。
- *URG*：标志紧急指针是否有效。URG控制位是用来告诉接收端在一个发送的IP数据包中某特定的数据是紧急的，需要优先处理。如果URG控制位置1，接收端就会分析紧急指针（IP报头中用一个16位的二进制表示），这个指针说明从首个字节开始多少个字节的数据是需要紧急处理的。

### 为什么需要 TCP 协议？ IP层实现控制不行吗

`IP` 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果在IP层实现控制，那么传输效率将大打折扣，因为一条数据在网络上会经过多个设备，如果每个设备都需要实现控制，那么传输效率降低

### 什么是TCP？

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

- **面向连接**：一定是「**一对一**」才能连接，不能像 UDP 协议可以**一个主机同时向多个主机发送消息**，也就是一对多是无法做到的；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- **字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

### TCP用来解决什么问题

TCP传输控制协议

控制可靠：有序传输，流量控制、拥塞控制

### UDP 和 TCP 有什么区别呢？分别的应用场景是？

UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。

UDP 协议真的非常简，头部只有 `8` 个字节（64 位），UDP 的头部格式如下：

![image-20240517162225545](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171622268.png)

- 目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。
- 包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。
- 校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。

**TCP 和 UDP 区别：**

*1. 连接*

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

*2. 服务对象*

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

*3. 可靠性*

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 **QUIC 协议**，具体可以参见这篇文章：[如何基于 UDP 协议实现可靠传输？(opens new window)](https://xiaolincoding.com/network/3_tcp/quic.html)

*4. 拥塞控制、流量控制*

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

*5. 首部开销*

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 **20 个字节**，如果使用了「选项」字段则会变长的。
- UDP 首部只有 **8 个字节**，并且是**固定不变**的，开销较小。

*6. 传输方式*

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

*7. 分片不同*

- TCP 的数据大小如果大于 MSS（MTU去掉TCP和IP头） 大小，则会在**传输层进行分片**，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 **IP 层进行分片**，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

**TCP 和 UDP 应用场景：**

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- `FTP` 文件传输；
- HTTP / HTTPS；

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 `DNS` 、`SNMP` 等；
- 视频、音频等多媒体通信；
- 广播通信；

> 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？

原因是 TCP 有**可变长**的「选项」字段，而 UDP 头部长度则是**不会变化**的，无需多一个字段去记录 UDP 的首部长度。

> 为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？

先说说 TCP 是如何计算负载数据长度：

![image-20240517162734946](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171627239.png)

其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。

大家这时就奇怪了问：“UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”

这么一问，确实感觉 UDP 的「包长度」是冗余的。

我查阅了很多资料，我觉得有两个比较靠谱的说法：

- 第一种说法：因为为了网络设备硬件设计和处理方便，首部长度需要是 `4` 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 `4` 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是 `4` 字节的整数倍，才补充了「包长度」字段。
- 第二种说法：如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。

### UDP如何实现一对多

常见的一对多通信方式主要有三种：

**广播（Broadcast）：** 广播数据包发送到整个网络中的所有设备，适用于局域网中的一对多通信。

**多播（组播）（Multicast）：** 数据包发送给一个组播组，组中的多个设备可以接收数据，适合有选择性的一对多通信场景。

**单播（Unicast）：** 虽然是点对点通信，但通过管理多个客户端的地址，可以依次发送给多个客户端，实现一对多通信。

### 端口号范围

端口范围0-65535

1. 公认端口（WellKnownPorts）

   从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。

2. 注册端口（RegisteredPorts）

   从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。

3. 动态和/或私有端口（Dynamicand/orPrivatePorts）

   从49152到65535。理论上，不应为服务分配这些端口。

### TCP 和 UDP 可以使用同一个端口吗？

答案：**可以的**。

在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过**端口进行寻址**，来识别同一计算机中同时通信的不同应用程序。

所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。

传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。

当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。

![image-20240517162916283](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171629505.png)

因此，TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。

关于端口的知识点，还是挺多可以讲的，比如还可以牵扯到这几个问题：

- 多个 TCP 服务进程可以同时绑定同一个端口吗？
- 重启 TCP 服务进程时，为什么会出现“Address in use”的报错信息？又该怎么避免？
- 客户端的端口可以重复使用吗？
- 客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？



### TCP建立连接

#### 三次握手的过程， 为什么不是两次或者四次

TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：

![image-20240420195357626](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404201953809.png)

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端**主动监听某个端口**，处于 `LISTEN` 状态

![image-20240420195208672](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404201952115.png)

- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。

![image-20240420195448536](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404201954182.png)

- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。

![image-20240420195554932](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404201956316.png)

- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以**携带客户到服务端的数据**，之后客户端处于 `ESTABLISHED` 状态。
- 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。

从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。

一旦完成三次握手，双方都处于 `ESTABLISHED` 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。

#### 如何在 Linux 系统中查看 TCP 状态？

TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。

![image-20240420195955519](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404201959696.png)

#### 为什么是三次握手？不是两次、四次？

相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”

这回答是没问题，但这回答是片面的，并没有说出主要的原因。

在前面我们知道了什么是 **TCP 连接**：

- 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 **Socket、序列号和窗口大小**称为连接。

所以，重要的是**为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。**

接下来，以三个方面分析三次握手的原因：

- 三次握手才可以阻止重复历史连接的初始化（主要原因）：三次握手可以防止旧的重复连接初始化造成混乱。例如，如果客户端的SYN请求连接在网络中阻塞，客户端没有接收到ACK报文，就会重新发送SYN。由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK确认信号，所以每收到一个SYN就只能先主动建立一个连接。这可能会导致服务器建立多个冗余的无效链接，造成不必要的资源开销。![image-20240517163420277](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171634985.png)
- 三次握手才可以同步双方的初始序列号：TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。如果只是**两次握手**，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。![image-20240517163630763](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171636659.png)
- 三次握手才可以避免资源浪费：如果只有两次握手，当客户端的SYN请求连接在网络中阻塞，客户端没有接收到ACK报文，就会重新发送SYN。由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK确认信号，所以每收到一个SYN就只能先主动建立一个连接。这可能会导致服务器建立多个冗余的无效链接，造成不必要的资源开销。![image-20240517163912533](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171639617.png)

不使用「两次握手」和「四次握手」的原因：

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

#### 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

主要原因有两个方面：

- 为了防止历史报文被下一个相同四元组的连接接收（主要方面）；![image-20240517164414351](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171644760.png)
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；

#### 初始序列号 ISN 是如何随机产生的？

起始 `ISN` 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。

RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。

- `M` 是一个计时器，这个计时器**每隔 4 微秒加 1**。
- `F` 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。

可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。

#### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

因为 **IP 层本身没有超时重传机制**，它由传输层的 TCP 来负责超时和重传。

当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」。

因此，可以得知由 IP 层进行分片传输，是非常没有效率的。

所以，为了达到最佳的传输效能 TCP 协议在**建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。

#### 第一次握手丢失了，会发生什么？ 客户端重传

当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 `SYN_SENT` 状态。

在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且**重传的 SYN 报文的序列号都是一样的**。

不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。

当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？

在 Linux 里，客户端的 SYN 报文最大重传次数由 `tcp_syn_retries`内核参数控制，这个参数是可以自定义的，默认值一般是 5。

```shell
# cat /proc/sys/net/ipv4/tcp_syn_retries
5
```

通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。

当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。

所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。

具体过程：

- 当客户端超时重传 3 次 SYN 报文后，由于 tcp_syn_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接

#### 第二次握手丢失了，会发生什么？ 互相重传

当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 `SYN_RCVD` 状态。

第二次握手的 `SYN-ACK` 报文其实有两个目的 ：

- 第二次握手里的 ACK， 是对第一次握手的确认报文；
- 第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；

所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？

因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）**丢失了**，于是**客户端就会触发超时重传机制，重传 SYN 报文**。

然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。

那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文**。

在 Linux 下，SYN-ACK 报文的最大重传次数由 `tcp_synack_retries`内核参数决定，默认值是 5。

```shell
# cat /proc/sys/net/ipv4/tcp_synack_retries
5
```

因此，当第二次握手丢失了，客户端和服务端都会重传：

- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 `tcp_syn_retries`内核参数决定；
- 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 `tcp_synack_retries` 内核参数决定。

举个例子，假设 tcp_syn_retries 参数值为 1，tcp_synack_retries 参数值为 2，那么当第二次握手一直丢失时，发生的过程如下图：

![image-20240517165503645](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171655137.png)

具体过程：

- 当客户端超时重传 1 次 SYN 报文后，由于 tcp_syn_retries 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。
- 当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。

#### 第三次握手丢失了，会发生什么？ 服务器重传，因为ACK报文丢失不会重传

客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态。

因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。

注意，**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

举个例子，假设 tcp_synack_retries 参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：

![image-20240517165701331](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171657501.png)

具体过程：

- 当服务端超时重传 2 次 SYN-ACK 报文后，由于 tcp_synack_retries 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。

#### 什么是 SYN 攻击？如何避免 SYN 攻击？

我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**，使得服务端不能为正常用户服务。

先跟大家说一下，什么是 TCP 半连接和全连接队列。

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accept 队列；

我们先来看下 Linux 内核的 `SYN` 队列（半连接队列）与 `Accpet` 队列（全连接队列）是如何工作的？

![image-20240517171851041](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171718157.png)

正常流程：

- 当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出连接对象。

不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。

SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。

避免 SYN 攻击方式，可以有以下四种方法：

- 调大 netdev_max_backlog：当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：
- 增大 TCP 半连接队列；
- 开启 tcp_syncookies：开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。
  - 具体过程：
    - 当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 `cookie` 值；
    - 将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；
    - 服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。
    - 最后应用程序通过调用 `accpet()` 接口，从「 Accept 队列」取出的连接

- 减少 SYN+ACK 重传次数

### TCP断开连接

#### TCP 四次挥手过程是怎样的？

天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过**四次挥手**方式。

双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：

![image-20240420202332396](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404202023066.png)

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

你可以看到，每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。

这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**

#### 为什么挥手需要四次？

再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。

但是**在特定情况下，四次挥手是可以变成三次挥手的**，具体情况可以看这篇：[TCP 四次挥手，可以变成三次吗？](https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html) TCP**延迟确认机制**：虽然**延迟确认策略**主要目的是提高数据传输效率，但在网络条件不佳或实现上的问题可能导致挥手过程中的ACK响应被无意中延迟。这种情况下，看起来好像是“减少”了步骤，实际上是因为ACK的发送被延后合并到了下一个合适的包中。这并不意味着挥手的步骤减少了，只是挥手过程中的响应时间可能被延长。

#### 第一次挥手丢失了，会发生什么？ 客户端重传

当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 `FIN_WAIT_1` 状态。

正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 `FIN_WAIT2`状态。

如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 `tcp_orphan_retries` 参数控制。

当客户端重传 FIN 报文的次数超过 `tcp_orphan_retries` 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 `close` 状态。

举个例子，假设 tcp_orphan_retries 参数值为 3，当第一次挥手一直丢失时，发生的过程如下图：

![image-20240517185226053](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171852591.png)

具体过程：

- 当客户端超时重传 3 次 FIN 报文后，由于 tcp_orphan_retries 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK报文），那么客户端就会断开连接。

#### 第二次挥手丢失了，会发生什么？ACK报文不会重传，还是客户端重传

当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 `CLOSE_WAIT` 状态。

在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。

举个例子，假设 tcp_orphan_retries 参数值为 2，当第二次挥手一直丢失时，发生的过程如下图：

![image-20240517185354102](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171853461.png)

#### 第三次挥手丢失了，会发生什么？服务器一直重传，FIN_WAIT2等到tcp_fin_timeout后进入close

当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 `CLOSE_WAIT` 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。

此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。

服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。

如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 `tcp_orphan_retrie`s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。

举个例子，假设 `tcp_orphan_retrie`s = 3，当第三次挥手一直丢失时，发生的过程如下图：

![image-20240517190155048](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171901322.png)

具体过程：

- 当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。
- 客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。

#### 第四次挥手丢失了，会发生什么？因为ACK不会重传，服务器重传，重置2MSL定时器

当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 `TIME_WAIT` 状态。

在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。

然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。

如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 `tcp_orphan_retries` 参数控制。

举个例子，假设 tcp_orphan_retries 为 2，当第四次挥手一直丢失时，发生的过程如下：

![image-20240517190955540](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405171909378.png)

具体过程：

- 当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。
- 客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。

#### 为什么 TIME_WAIT 等待的时间是 2MSL？

`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。

**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了**。

TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。

比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 `FIN` 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。

可以看到 **2MSL时长** 这其实是相当于**至少允许报文丢失一次**。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。

为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。

`2MSL` 的时间是从**客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 **2MSL 时间将重新计时**。

在 Linux 系统里 `2MSL` 默认是 `60` 秒，那么一个 `MSL` 也就是 `30` 秒。**Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒**。

其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：

```c
#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT 
                                    state, about 60 seconds  */
```

如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。

1. 至少允许报文丢失一次
2. 如果太长，效率太低

#### 为什么需要 TIME_WAIT 状态？

主动发起关闭连接的一方，才会有 `TIME-WAIT` 状态。

需要 TIME-WAIT 状态，主要是两个原因：

- **处理延迟的重复报文**：避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接。TCP连接关闭后，网络中可能仍然存在旧的、延迟的数据包。TIME_WAIT状态的持续时间（通常是2倍的最大报文段生存时间，2MSL）可以确保这些旧数据包有足够的时间被网络清除，从而避免它们影响后续的新连接。
- **优雅的关闭TCP连接**：保证「被动关闭连接」的一方，能被正确的关闭；TIME_WAIT状态确保了最后的ACK包能够被对方接收到。假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。

#### 服务器出现大量 TIME_WAIT 状态的原因有哪些？

首先要知道 TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。

问题来了，什么场景下服务端会主动断开连接呢？ 

- 第一个场景：HTTP 没有使用长连接 [无论是客户端还是服务器关闭长连接，都是**服务器主动关闭连接**]
- 第二个场景：HTTP 长连接超时 【为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，比如 nginx 提供的 keepalive_timeout 参数。】
- 第三个场景：HTTP 长连接的请求数量达到上限【Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。】

#### TIME_WAIT 过多有什么危害？

过多的 TIME-WAIT 状态主要的危害有两种：

- 第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；
- 第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 `32768～61000`，也可以通过 `net.ipv4.ip_local_port_range`参数指定范围。

#### 怎么解决TIME_WAIT过多

首先，考虑到TIME_WAIT状态主要是为了确保关闭连接的请求和最后的ACK能够被对方正确接收，我会尝试优化TCP参数配置。具体来说，可以调整TCP的SO_REUSEADDR选项，允许端口复用，这样即使端口处于TIME_WAIT状态，也可以被新的连接所使用，从而避免了端口资源耗尽的问题。【端口复用】

其次，我会从应用程序的设计层面进行优化。例如，对于频繁进行短连接操作的场景，我会考虑使用长连接或者连接池技术来减少连接的频繁建立和关闭。这样不仅可以减少TIME_WAIT状态的数量，还能提高系统的整体性能。【短连接改长连接】

另外，我也会关注服务端和客户端之间的网络通信质量。如果网络通信不稳定或者存在延迟，可能会导致连接在关闭后仍然长时间处于TIME_WAIT状态。因此，我会尝试优化网络环境，减少网络延迟和丢包率，从而降低TIME_WAIT状态的数量。

最后，如果服务端确实需要频繁地关闭和打开连接，并且无法避免大量的TIME_WAIT状态，我会考虑增加服务端的端口范围，以确保即使有大量TIME_WAIT状态存在，也不会耗尽所有可用端口。

#### 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？

CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。 

所以，**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。** 那什么情况会导致服务端的程序没有调用 close 函数关闭连接？这时候通常需要排查代码。 

我们先来分析一个普通的 TCP 服务端的流程： 

1. 创建服务端 socket，bind 绑定端口、listen 监听端口 
2. 将服务端 socket 注册到 epoll 
3. epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket 
4. 将已连接的 socket 注册到 epoll 
5. epoll_wait 等待事件发生 
6. 对方连接关闭时，我方调用 close

可能导致服务端没有调用 close 函数的原因，如下。 

**第一个原因**：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。 不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。 

**第二个原因**： 第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。 发生这种情况可能是因为服务端在执行 accpet 函数之前，代码卡在某一个逻辑或者提前抛出了异常。 

**第三个原因**：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。 发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。

**第四个原因**：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。 

可以发现，当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close。

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景（而不是进程崩溃）。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 ESTABLISH 状态，占用着系统资源。 

为了避免这种情况，TCP 搞了个保活机制。这个机制的原理是这样的： 

定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。 

#### 如果已经建立了连接，但是服务端的进程崩溃会发生什么？

TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。

#### TCP四次挥手可以变成三次吗

如果**没有数据要发送**并且开启了Delay ACK，那么第二次和第三次挥手会进行合并。

Dalay ACK：

当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 Delay ACK。

Delay ACK的策略： 

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409041907861.png)

关闭 Delay ACK 的方法：可以给 socket 设置 `TCP_QUICKACK`，这样自己（作为 server 端）在收到 TCP segment 的时候会立即 ACK。实际上，在现在的 Linux 系统默认就是关闭的。

### TCP的重传机制

#### 重传机制

TCP 实现可靠传输的方式之一，是通过序列号与确认应答。

在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。

但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？

所以 TCP 针对数据包丢失的情况，会用**重传机制**解决。

接下来说说常见的重传机制：

- 超时重传
- 快速重传
- SACK
- D-SACK

#### 超时重传

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。

TCP 会在以下两种情况发生超时重传：

- 数据包丢失
- 确认应答丢失

![image-20240427185104307](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404271851931.png)

> 超时时间应该设置为多少呢？

我们先来了解一下什么是 `RTT`（Round-Trip Time 往返时延），从下图我们就可以知道：

![image-20240427185128455](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404271851939.png)

`RTT` 指的是**数据发送时刻到接收到确认的时刻的差值**，也就是包的往返时间。

超时重传时间是以 `RTO` （Retransmission Timeout 超时重传时间）表示。

假设在重传的情况下，超时时间 `RTO` 「较长或较短」时，会发生什么事情呢？

![image-20240427185230972](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404271852714.png)

上图中有两种超时时间不同的情况：

- 当超时时间 **RTO 较大**时，重发就慢，丢了老半天才重发，没有效率，性能差；
- 当超时时间 **RTO 较小**时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。

精确的测量超时时间 `RTO` 的值是非常重要的，这可让我们的重传机制更高效。

根据上述的两种情况，我们可以得知，**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**。

![image-20240427185256539](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404271852582.png)

至此，可能大家觉得超时重传时间 `RTO` 的值计算，也不是很复杂嘛。

好像就是在发送端发包时记下 `t0` ，然后接收端再把这个 `ack` 回来时再记一个 `t1`，于是 `RTT = t1 – t0`。没那么简单，**这只是一个采样，不能代表普遍情况**。

实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个**动态变化的值**。

我们来看看 Linux 是如何计算 `RTO` 的呢？

估计往返时间，通常需要采样以下两个：

- 需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。
- 除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**超时间隔加倍。**

也就是**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**

超时触发重传存在的问题是，**超时周期可能相对较长**。那是不是可以有更快的方式呢？

于是就可以用「快速重传」机制来解决超时重发的时间等待

#### 快速重传

TCP 还有另外一种**快速重传（Fast Retransmit）机制**，它**不以时间为驱动，而是以数据驱动重传**。

快速重传机制，是如何工作的呢？其实很简单，一图胜千言。

![image-20240427185414386](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404271854877.png)

在上图，发送方发出了 1，2，3，4，5 份数据：

- 第一份 Seq1 先送到了，于是就 Ack 回 2；
- 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
- 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
- **发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。**
- 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。

所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是**重传的时候，是重传一个，还是重传所有的问题。**

举个例子，假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？

- 如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为对于丢失的 Seq3 报文，还得在后续收到三个重复的 ACK3 才能触发重传。
- 如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2 和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传 Seq4 ～Seq6 折部分数据相当于做了一次无用功，浪费资源。

可以看到，不管是重传一个报文，还是重传已发送的报文，都存在问题。

为了解决不知道该重传哪些 TCP 报文，于是就有 `SACK` 方法。

#### SACK 方法

还有一种实现重传机制的方式叫：`SACK`（ Selective Acknowledgment）， **选择性确认**。

这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 `SACK` 信息发现只有 `200~299` 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。

![image-20240427192126254](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404271921147.png)

#### Duplicate SACK

Duplicate SACK 又称 `D-SACK`，其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。**

下面举例两个栗子，来说明 `D-SACK` 的作用。

- 「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）
- **于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500**，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 `D-SACK`。
- 这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。

![image-20240427194124932](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202404271941724.png)

![image-20240517201122155](C:/Users/10503/AppData/Roaming/Typora/typora-user-images/image-20240517201122155.png)

- 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。
- 而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；
- **所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。**
- 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

### 流量控制

TCP 引入了**窗口**这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

那么有了窗口，就可以指定窗口大小，窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

1. **滑动窗口：**TCP协议中的滑动窗口机制是实现流量控制的一种重要方法。发送方和接收方各自维护一个窗口，窗口的大小表示了对方还能接收的数据量。发送方根据接收方的窗口大小来控制发送的数据量，从而避免接收方的缓冲区溢出。
2. **接收方通知窗口大小：**在TCP首部中，有一个字段用于通知窗口大小，接收方将自己可以接收的缓冲区大小放在该字段中通知发送方。当接收方的缓冲区面临数据溢出时，窗口大小的值也会随之改变，设置为一个更小的值通知发送方，从而控制数据的发送量。
3.  **限流：**在某些情况下，例如微服务架构中，可能需要对某个服务的流量进行限制。这通常通过一些限流算法来实现，例如计数器、滑动窗口、漏桶、令牌桶等。这些算法可以精确地控制在单位时间内的处理量，从而保证系统不被冲垮，同时尽可能提升系统的吞吐量。

#### 糊涂窗口综合症

“**糊涂窗口综合症**”（**Silly Window Syndrome**）是指由于传输控制协议（TCP）中的窗口大小管理不当，导致网络性能低下的一种现象。

涂窗口综合症的现象是可以发生在发送方和接收方：

- 接收方可以通告一个小的窗口
- 而发送方可以发送小数据

接收方通常的策略如下: 当「窗口大小」**小于 min( MSS，缓存空间/2 )** ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。 等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。

接收方：使用nagle算法

### 拥塞控制

前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。

**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

于是，就有了**拥塞控制**，控制的目的就是**避免「发送方」的数据填满整个网络。**

为了在「发送方」调节所要发送数据的量，定义了一个叫做「**拥塞窗口**」的概念。

> 什么是拥塞窗口？和发送窗口有什么关系呢？

**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。

我们在前面提到过发送窗口 `swnd` 和接收窗口 `rwnd` 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。

拥塞窗口 `cwnd` 变化的规则：

- 只要网络中没有出现拥塞，`cwnd` 就会增大；
- 但网络中出现了拥塞，`cwnd` 就减少；

> 那么怎么知道当前网络是否出现了拥塞呢？

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞。**

> 拥塞控制有哪些控制算法？

拥塞控制主要是四个算法：

- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复

#### 慢启动

TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？

慢启动的算法记住一个规则就行：**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**

这里假定拥塞窗口 `cwnd` 和发送窗口 `swnd` 相等，下面举个栗子：

- 连接建立完成后，一开始初始化 `cwnd = 1`，表示可以传一个 `MSS` 大小的数据。
- 当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个
- 当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个
- 当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。

慢启动算法的变化过程如下图：

![image-20240517202611250](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405172026605.png)

可以看出慢启动算法，发包的个数是**指数性的增长**。

> 那慢启动涨到什么时候是个头呢？

有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量。

- 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
- 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。

#### 拥塞避免算法

前面说道，当拥塞窗口 `cwnd` 「超过」慢启动门限 `ssthresh` 就会进入拥塞避免算法。

一般来说 `ssthresh` 的大小是 `65535` 字节。

那么进入拥塞避免算法后，它的规则是：**每当收到一个 ACK 时，cwnd 增加 1/。**

接上前面的慢启动的栗子，现假定 `ssthresh` 为 `8`：

- 当 8 个 ACK 应答确认到来时，增加 1，于是这一次能够发送 9 个 `MSS` 大小的数据，变成了**线性增长。**

拥塞避免算法的变化过程如下图

![image-20240517202832313](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405172028481.png)

所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。

就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

当触发了重传机制，也就进入了「拥塞发生算法」

#### 拥塞发生

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

- 超时重传
- 快速重传

这两种使用的拥塞发送算法是不同的，接下来分别来说说。

##### **超时重传**

当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：

- `ssthresh` 设为 `cwnd/2`，
- `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

![image-20240517203241043](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405172032021.png)

接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。

就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。

##### **快重传快恢复**

还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 `ssthresh` 和 `cwnd` 变化如下：

- `ssthresh  = cwnd/2` ，也就是设置为原来的一半;
- `cwnd= ssthresh  `;
- cwnd从ssthreth开始使用拥塞避免

![image-20240517204135779](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405172041362.png)

### TCP有哪些保证可靠的机制

连接管理：三次握手、四次挥手

校验和：首部有一个校验和字段，发送方对**发送数据的二进制求和取反**，然后填充到这个字段中，接收方收到数据以相同的方式计算，如果不同丢弃

序列号：保证有序

确认应答号：用于告知接收方收到数据

超时重传

流量控制

拥塞控制

### 如何理解是 TCP 面向字节流协议？

#### 如何理解字节流？

**先来说说为什么 UDP 是面向报文的协议？**

当用户消息通过 UDP 协议传输时，**操作系统不会对消息进行拆分**，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是**每个 UDP 报文就是一个用户消息的边界**，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。

你可能会问，如果收到了两个 UDP 报文，操作系统是怎么区分开的？

操作系统在收到 UDP 报文后，会将其插入到队列里，**队列里的每一个元素就是一个 UDP 报文**，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。

![image-20240517205555791](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405172055032.png)

**再来说说为什么 TCP 是面向字节流的协议？**

当用户消息通过 TCP 协议传输时，**消息可能会被操作系统分组成多个的 TCP 报文**，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。

这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。

举个实际的例子来说明。

发送方准备发送 「Hi.」和「I am Xiaolin」这两个消息。

在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。

至于什么时候真正被发送，**取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件**。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去。

如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用 send 函数先后发送 「Hi.」和「I am Xiaolin」 报文，那么实际的发送很有可能是这几种情况。

第一种情况，这两个消息被分到同一个 TCP 报文，像这样：

![image-20240517205811432](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405172058576.png)

第二种情况，「I am Xiaolin」的部分随 「Hi」 在一个 TCP 报文中发送出去，像这样：

![image-20240517205841799](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405172058897.png)

类似的情况还能举例很多种，这里主要是想说明，我们不知道 「Hi.」和 「I am Xiaolin」 这两个用户消息是如何进行 TCP 分组传输的。

因此，**我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议**。

当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。

要解决这个问题，要交给**应用程序**。

#### 粘包发生的原因有哪些？

- **网络延迟**：由于网络延迟，数据包可能会在传输过程中被粘在一起。
- **网络拥塞**：当网络拥塞时，数据包可能会被卡在发送方和接收方之间，无法正确地被接收方解析。
- **数据包大小**：如果数据包过大，它们可能会在传输过程中被粘在一起。

#### 如何解决粘包？

粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。

一般有三种分包的方式：

- 固定长度的消息；
- 特殊字符作为边界；
- 自定义消息结构。

##### 固定长度的消息

这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。

但是这种方式灵活性不高，实际中很少用。

##### 特殊字符作为边界

我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。

HTTP 是一个非常好的例子。

![image-20240517210532674](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405172105973.png)

HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。

有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。

##### 自定义消息结构

我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。

比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。

```c
struct { 
    u_int32_t message_length; 
    char message_data[]; 
} message;
```

当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。

#### 封包和拆包你听说过吗？它是基于TCP还是UDP的？

封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。

- 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。
- 拆包：接收方在接收到报文后提取包头中的长度信息进行截取。

####  **为什么UDP没有粘包？**

1. **面向报文：**UDP是面向报文的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据。这与TCP协议不同，TCP协议是面向流的，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的。
2. **消息边界：**UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说就容易进行区分处理了。
3. **无Nagle算法：**UDP发送的时候，没有经过Nagle算法优化，不会将多个小包合并一次发送出去。Nagle算法是TCP协议中的一种优化算法，它会将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。

### 可以解释一下RTO，RTT和超时重传分别是什么吗？

- 超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：
  - 发送的数据没能到达接收端，所以对方没有响应。
  - 接收端接收到数据，但是ACK报文在返回过程中丢失。
  - 接收端拒绝或丢弃数据。
- RTO（Retransmission Time Out 重传时间）：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。
  - 通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......
  - 重传次数到达上限之后停止重传。
- RTT（Round trip time连接的往返时间）：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。

### 拔掉网线后， 原本的 TCP 连接还存在吗？

客户端拔掉网线后，并不会直接影响 TCP 连接状态。TCP 连接在 Linux 内核中是一个名为 struct socket 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。 

有数据传输的情况： 

- 在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。 
- 在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。

没有数据传输的情况：

- 如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。 
- 如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。

### TCP 和 UDP 可以使用同一个端口吗？

#### TCP 和 UDP 可以同时绑定相同的端口吗？

可以的。

TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。

当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。

因此， TCP/UDP 各自的端口号也相互独立，互不影响。

#### 多个 TCP 服务进程可以同时绑定同一个端口吗？

如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。

如果两个 TCP 服务进程绑定的端口都相同，而 IP 地址不同，那么执行 bind() 不会出错。

#### 如何解决服务端重启时，报错“Address already in use”的问题？

当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。

当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。

要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。

这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。

#### 客户端的端口可以重复使用吗？

在客户端执行 connect 函数的时候，只要客户端连接的服务器不是同一个，内核允许端口重复使用。

TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。

所以，如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。

#### 客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？

要看客户端是否都是与同一个服务器（目标地址和目标端口一样）建立连接。

如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。即使在这种状态下，还是可以与其他服务器建立连接的，只要客户端连接的服务器不是同一个，那么端口是重复使用的。

#### 如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？

打开 net.ipv4.tcp_tw_reuse 这个内核参数。

因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态。

如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。

#### tw_reuse和SO_REUSEADDR区别

tcp_tw_reuse 是内核选项，主要用在**连接的发起方**。**TIME_WAIT 状态的连接创建时间超过 1 秒后**，新的连接才可以被复用，注意，这里是连接的发起方；

SO_REUSEADDR 是**用户态的选项**，SO_REUSEADDR 选项用来告诉操作系统内核，如果端口已被占用，但是 **TCP 连接状态位于 TIME_WAIT ，可以重用端口**。如果端口忙，而 TCP 处于其他状态，重用端口时依旧得到“Address already in use”的错误信息。注意，这里一般都是连接的服务方。

### TSL升级

在 TLS 1.2 的握手中，一般是需要 4 次握手，先要通过 Client Hello （第 1 次握手）和 Server Hello（第 2 次握手） 消息协商出后续使用的加密算法，再互相交换公钥（第 3 和 第 4 次握手），然后计算出最终的会话密钥，下图的左边部分就是 TLS 1.2 的握手过程：

![image-20240531152050178](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202405311520394.png)

上图的右边部分就是 TLS 1.3 的握手过程，可以发现 **TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手**。

怎么合并的呢？具体的做法是，客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。

服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。

而且，TLS1.3 对密码套件进行“减肥”了， **对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法**。

### TCP协议有哪些缺陷？

- 升级 TCP 的工作很困难；
- TCP 存在队头阻塞问题；前面消息丢失，即使后面消息收到内核也无法读取
- TCP 建立连接的延迟；
- 网络迁移需要重新建立 TCP 连接；

### QUIC如何实现可靠传输

要基于 UDP 实现的可靠传输协议，那么就要在应用层下功夫，也就是要设计好协议的头部字段。

拿 HTTP/3 举例子，在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部：

![img](https://cdn.xiaolincoding.com//mysql/other/ab3283383013b707d1420b6b4cb8517c.png)

**packet header**

![Packet Header](https://cdn.xiaolincoding.com//mysql/other/bcf3ccb6a15c4cdebe1cd0527fdd9a5e.png)

packet header分为两种

long packet header：用于首次连接

short packet header：用于异常传输数据

QUIC 也是需要三次握手来建立连接的，主要目的是为了协商连接 ID。协商出连接 ID 后，后续传输时，双方只需要固定住连接 ID，从而实现连接迁移功能。所以，你可以看到日常传输数据的 Short Packet Header 不需要在传输 Source Connection ID 字段了，只需要传输 Destination Connection ID。 

Short Packet Header 中的 Packet Number 是每个报文独一无二的编号，它是**严格递增**的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。

所以，Packet Number 单调递增的两个好处： 

可以更加精确计算 RTT，没有 TCP 重传的歧义性问题； 

可以支持乱序确认，不会因为丢包重传将当前窗口阻塞在原地，而 TCP 必须是顺序确认的，丢包时会导致窗口不滑动；

**QUIC Frame Header**

一个 Packet 报文中可以存放多个 QUIC Frame。

![img](https://cdn.xiaolincoding.com//mysql/other/6a94d41ef3d14cb6b7846e73da6c3104.png)

每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。 

我这里只举例 Stream 类型的 Frame 格式，Stream 可以认为就是一条 HTTP 请求，它长这样：

![img](https://cdn.xiaolincoding.com//mysql/other/536298d2c54a43b699026bffe0f85010.png)

Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID； Offset 作用：类似于 TCP 协议中的 Seq 序号，保证数据的顺序性和可靠性； 

Length 作用：指明了 Frame 数据的长度。



**通过 Stream ID + Offset 字段信息实现数据的有序性**，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。



**QUIC解决队头阻塞**

**HTTP/2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。**



QUIC 也借鉴 HTTP/2 里的 Stream 的概念，在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (Stream)。 

但是 **QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口。** 

假如 Stream2 丢了一个 UDP 包，也只会影响 Stream2 的处理，不会影响其他 Stream，与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409102109609.jpeg)

### SYN报文什么情况下会被丢弃

TCP两个队列满了，造成SYN报文丢弃

 在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是： 

- 半连接队列，也称 SYN 队列； 
- 全连接队列，也称 accepet 队列； 

服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。

![半连接队列与全连接队列](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408161044462.png)

#### 半连接队列满了

当服务器造成syn攻击，就有可能导致 **TCP 半连接队列满了，这时后面来的 syn 包都会被丢弃。** 

但是，**如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包**。 

syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功，如下图所示。

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408161257719.png)

syncookies 参数主要有以下三个值： 

0 值，表示关闭该功能； 

1 值，表示仅当 SYN 半连接队列放不下时，再启用它； 

2 值，表示无条件开启功能； 

那么在应对 SYN 攻击时，只需要设置为 1 即可

#### 全连接队列满了

在服务端并发处理大量请求时，如果 TCP accpet 队列过小，或者应用程序调用 accept() 不及时，就会造成 accpet 队列满了 ，这时后续的连接就会被丢弃，这样就会出现服务端请求数量上不去的现象。

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408161259958.png)

我们可以通过 ss 命令来看 accpet 队列大小，在「LISTEN 状态」时，Recv-Q/Send-Q 表示的含义如下： 

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408161300314.png)Recv-Q：当前 accpet 队列的大小，也就是当前已完成三次握手并等待服务端 accept() 的 TCP 连接个数； 

Send-Q：当前 accpet 最大队列长度，上面的输出结果说明监听 8088 端口的 TCP 服务进程，accpet 队列的最大长度为 128； 

如果 Recv-Q 的大小超过 Send-Q，就说明发生了 accpet 队列满的情况。 

要解决这个问题，我们可以： 调大 accpet 队列的最大长度，调大的方式是通过调大 backlog 以及 somaxconn 参数。 检查系统或者代码为什么调用 accept() 不及时；

### 服务器的最大连接数

1如何确定一个TCP连接 TCP四元组可唯一确定一个TCP连接。四元组中包含： 源地址，源端口，目标地址，目标端口。 源地址和目标地址的字段(32位)在ip头部中，作用：通过IP协议发送报文到目标主机。 源端口和目标端口的字段(16位)在TCP头部中，作用：告诉TCP协议应该把报文发送给哪个进程。 2.TCP最大连接数量 客户端IP数量 * 客户端端口数量 对于IPV4：客户端最大IP数量位2的32次方，客户端端口数量为2的16次放，即服务器单机最大连接数量约为2的48次方。 但服务器最大并发TCP连接数量远远不能达到理论上限。 

1.文件描述符限制，Socket都是文件，所以首先通过ulimit -n配置文件描述符的数量。 

2.内存限制，每个TCP连接都占用一定的内存，操作系统的内存是有限的。

### Socket编程

![基于 TCP 协议的客户端和服务端工作](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408051310128.png)

1. 服务端和客户端初始化 socket，得到文件描述符； 
2. 服务端调用 bind，将 socket 绑定在指定的 IP 地址和端口; 
3. 服务端调用 listen，进行监听； 
4. 服务端调用 accept，等待客户端连接；
5. 客户端调用 connect，向服务端的地址和端口发起连接请求；
6. 服务端 accept 返回用于传输的 socket 的文件描述符； 
7. 客户端调用 write 写入数据；服务端调用 read 读取数据； 
8. 客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。 

这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。 所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。 成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。

函数原型

```c
int socket(int domain, int type, int protocol);
domain: 指定套接字使用的协议族。例如：

AF_INET: IPv4 协议
AF_INET6: IPv6 协议
AF_UNIX: 本地通信（UNIX 域套接字）
    
type: 指定套接字的类型。例如：
SOCK_STREAM: 流式套接字（TCP）
SOCK_DGRAM: 数据报套接字（UDP）
SOCK_RAW: 原始套接字
    
protocol: 指定使用的协议。通常可以设置为 0，让系统自动选择与套接字类型匹配的默认协议。例如，对于 SOCK_STREAM，默认协议是 IPPROTO_TCP，对于 SOCK_DGRAM，默认协议是 IPPROTO_UDP。
    
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
sockfd: 套接字描述符，标识一个套接字。
addr: 指向 sockaddr 结构体的指针，该结构体包含要绑定的地址信息（IP 地址和端口号）。
addrlen: sockaddr 结构体的大小（字节数）。

返回值：
成功时返回 0。
失败时返回 -1，并设置 errno 来指示错误。
    
int listen(int sockfd, int backlog);
sockfd: 套接字描述符。
backlog: 在队列中允许的最大未完成连接数。
    
返回值：
成功时返回 0。
失败时返回 -1，并设置 errno 来指示错误。
    
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
sockfd: 套接字描述符，必须是通过 listen 函数设置为被动模式的套接字。
addr: 指向 sockaddr 结构体的指针，用于存储连接的客户端地址。
addrlen: 指向 socklen_t 类型的指针，表示 addr 结构体的大小。函数执行后，该值会被更新为实际客户端地址的大小。
返回值：

成功时返回新的套接字描述符，用于与客户端通信。
失败时返回 -1，并设置 errno 来指示错误。
```



```c
// server.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>

int main()
{
    // 1. 创建监听的套接字
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    // 2. 将socket()返回值和本地的IP端口绑定到一起
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(10000);   // 大端端口
    // INADDR_ANY代表本机的所有IP, 假设有三个网卡就有三个IP地址
    // 这个宏可以代表任意一个IP地址
    addr.sin_addr.s_addr = INADDR_ANY;  // 这个宏的值为0 == 0.0.0.0
    int ret = bind(lfd, (struct sockaddr*)&addr, sizeof(addr));
    // 3. 设置监听
    ret = listen(lfd, 128);
    // 4. 阻塞等待并接受客户端连接
    struct sockaddr_in cliaddr;
    int clilen = sizeof(cliaddr);
    int cfd = accept(lfd, (struct sockaddr*)&cliaddr, &clilen);
    // 5. 和客户端通信
    while(1)
    {
        // 接收数据
        char buf[1024];
        memset(buf, 0, sizeof(buf));
        int len = read(cfd, buf, sizeof(buf));
        if(len > 0)
        {
            printf("客户端say: %s\n", buf);
            write(cfd, buf, len);
        }
        else if(len  == 0)
        {
            printf("客户端断开了连接...\n");
            break;
        }
        else
        {
            perror("read");
            break;
        }
    }
    close(cfd);
    close(lfd);
    return 0;
}

```

`read`返回值：

- 大于0：表示成功读取到的字节数，如果你请求读取 100 字节，但返回值是 50，则表示实际读取了 50 字节的数据。
- 等于0：对端已经关闭连接
- -1：表示读操作读取失败，可以通过errno查看具体的错误类型

> `errno` 是一个全局变量，用于指示最近一次系统调用或库函数调用失败的错误代码。每当系统调用或库函数返回错误（通常是 `-1`），`errno` 会被设置为一个特定的值，表示错误的具体类型。你可以通过检查 `errno` 的值来了解错误的原因。
>
> - **`EINTR`**: 读取操作被信号中断，可以尝试重新读取。
> - **`EAGAIN` 或 `EWOULDBLOCK`**: 在非阻塞模式下，文件描述符当前没有数据可读取，可以稍后重试。
> - **`EBADF`**: 文件描述符无效，可能是因为文件描述符未打开或已关闭。
> - **`EIO`**: I/O 错误，可能是硬件故障或文件系统错误。
> - **`EINVAL`**: 参数无效，例如读取的缓冲区大小为负数。

####  listen 时候参数 backlog 的意义？

Linux内核中会维护两个队列： 

- 半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态； 
- 全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；

![ SYN 队列 与 Accpet 队列 ](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408161021952.png)

```c
int listen (int socketfd, int backlog) 
```

- 参数一 socketfd 为 socketfd 文件描述符 
- 参数二 backlog，这参数在历史版本有一定的变化 

在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。 

在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，所以现在通常认为 backlog 是 accept 队列。 但是上限值是内核参数 **somaxconn** 的大小，也就说 **accpet 队列长度 = min(backlog, somaxconn)。**

####  accept 发生在三次握手的哪一步？

![socket 三次握手](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408161024941.png)



- 客户端的协议栈向服务端发送了 SYN 包，并告诉服务端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态;
- 服务端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务端也发送一个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务端进入 SYN_RCVD 状态；
- 客户端协议栈收到 ACK 之后，使得应用程序从 connect 调用返回，表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务端的 SYN 包进行应答，应答数据为 server_isn+1;
- ACK 应答包到达服务端后，服务端的 TCP 连接进入 ESTABLISHED 状态，同时服务端协议栈使得 accept 阻塞调用返回，这个时候服务端到客户端的单向连接也建立成功。至此，客户端与服务端两个方向的连接都建立成功。
- 从上面的描述过程，**我们可以得知客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后**

#### 客户端调用 close 了，连接是断开的流程是什么？

![客户端调用 close 过程](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408161031582.png)

- 客户端调用 close，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态； 
- 服务端接收到了 FIN 报文，TCP协议栈会在接收缓冲区中插入一个EOF（文件结束符），**这个 EOF 会被放在已排队等候的其他已接收的数据之后**，这意味着应用程序需要先处理完所有已接收的数据，才能感知到这个EOF。当服务器处理完这些数据并检测到EOF时，服务器进入 `CLOSE_WAIT` 状态。这意味着服务器知道客户端已经关闭了发送方向的数据流，但它还需要继续处理它自己的剩余数据。
- 当服务器处理完所有接收的数据后，应用程序通常会调用 `close` 函数关闭服务器端的套接字。这会使得服务器端TCP协议栈发送一个FIN包，通知客户端服务器也没有数据要发送了。发送FIN包后，服务器进入 `LAST_ACK` 状态
- 客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态； 
- 服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态； 
- 客户端经过 2MSL 时间之后，也进入 CLOSE 状态；

#### 没有 accept，能建立 TCP 连接吗？

accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。

![半连接队列与全连接队列](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202408161044462.png)

#### 没有 listen，能建立 TCP 连接吗？

客户端是可以自己连自己的形成连接（**TCP自连接**），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是**没有服务端参与，也就是没有 listen，就能 TCP 建立连接**。



**那么客户端会有半连接队列吗？** 

显然没有，因为客户端没有执行listen，因为半连接队列和全连接队列都是在执行 listen 方法时，内核自动创建的。 

但内核还有个全局 hash 表，可以用于存放 sock 连接的信息。 

这个全局 hash 表其实还细分为 ehash，bhash和listen_hash等，但因为过于细节，大家理解成有一个全局 hash 就够了， 

在 TCP 自连接的情况中，客户端在 connect 方法时，**最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候**，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。

#### 服务端没有 listen，客户端发起连接建立，会发生什么？

服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。

由于服务器端没有调用 `listen`，因此它不会监听任何端口，也无法处理任何传入的连接请求。服务器上的TCP/IP协议栈会识别到目标端口没有在监听状态，因此无法响应客户端的SYN包。服务器会返回一个 RST（Reset）包给客户端。这个RST包告诉客户端，该端口不可用或没有服务在此端口上监听。这种情况可能是因为服务器程序没有启动、端口配置错误，或其他原因导致服务器没有进入监听状态。

#### TCP和UDP的发送和接收缓冲区

怎么观察socket缓冲区 `netstat -nt`，Recv-Q是接收缓冲区，Send-Q是发送缓冲区

##### TCP

**执行 send 发送的字节，会立马发送吗？**

答案是不确定！执行 send 之后，数据只是拷贝到了socket 缓冲区。至于什么时候会发数据，发多少数据，全听操作系统安排。

send会将数据一路传输到传输层，识别到tcp协议后，会调用tcp_sendmsg方法。在 tcp_sendmsg 中， 核心工作就是将待发送的数据组织按照先后顺序放入到发送缓冲区中， 然后根据实际情况（比如拥塞窗口等）判断是否要发数据。如果不发送数据，那么此时直接返回。

**如果缓冲区满了会怎么办**

前面提到的情况里是，发送缓冲区有足够的空间，可以用于拷贝待发送数据。

**如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？**

这里分两种情况。

首先，socket在创建的时候，是可以设置是**阻塞**的还是**非阻塞**的。

将 `socket` 设置为**非阻塞** （`SOCK_NONBLOCK`）。

当发送缓冲区**满了**，如果还向socket执行send

- 如果此时 socket 是阻塞的，那么程序会在那**干等、死等**，直到释放出新的缓存空间，就继续把数据拷进去，然后**返回**。
- 果此时 socket 是非阻塞的，程序就会**立刻返回**一个 `EAGAIN` 错误信息，意思是 `Try again` , 现在缓冲区满了，你也别等了，待会再试一次。



**如果接收缓冲区为空，执行 recv 会怎么样？**

接收缓冲区也是类似的情况。

当接收缓冲区**为空**，如果还向socket执行 recv

- 如果此时 socket 是阻塞的，那么程序会在那**干等**，直到接收缓冲区有数据，就会把数据从接收缓冲区拷贝到用户缓冲区，然后**返回**。
- 如果此时 socket 是非阻塞的，程序就会**立刻返回**一个 `EAGAIN` 错误信息。



**如果socket缓冲区还有数据，执行close了，会怎么样？**

首先我们要知道，**一般正常情况下，发送缓冲区和接收缓冲区 都应该是空的。**

如果发送、接收缓冲区长时间非空，说明有数据堆积，这往往是由于一些网络问题或用户应用层问题，导致数据没有正常处理。

那么正常情况下，如果 `socket` 缓冲区**为空**，执行 `close`。就会触发四次挥手。

**如果接收缓冲区有数据时，执行close了，会怎么样？**

`socket close` 时，主要的逻辑在 `tcp_close()` 里实现。

先说结论，关闭过程主要有两种情况：

- 如果接收缓冲区还有数据未读，会先把接收缓冲区的数据清空，然后给对端发一个RST。
- 如果接收缓冲区是空的，那么就调用 `tcp_send_fin()` 开始进行四次挥手过程的第一次挥手。

**如果发送缓冲区有数据时，执行close了，会怎么样？**

此时，还有些数据没发出去，内核会把发送缓冲区最后一个数据块拿出来。然后置为 FIN。

`socket` 缓冲区是个**先进先出**的队列，这种情况是指内核会等待TCP层安静把发送缓冲区数据都发完，最后再执行 四次挥手的第一次挥手（FIN包）。

有一点需要注意的是，只有在**接收缓冲区为空的前提下**，我们才有可能走到 `tcp_send_fin()` 。而只有在进入了这个方法之后，我们才有可能考虑发送缓冲区是否为空的场景。

##### UDP

一般正常情况下，会把数据直接拷到发送缓冲区后直接发送。

还有一种情况，是在发送数据的时候，设置一个 `MSG_MORE` 的标记。

```c
ssize_t send(int sock, const void *buf, size_t len, int flags); // flag 置为 MSG_MORE
```

大概的意思是告诉内核，待会还有其他**更多消息**要一起发，先别着急发出去。此时内核就会把这份数据先用**发送缓冲区**缓存起来，待会应用层说ok了，再一起发。

因此，不管是不是 `MSG_MORE`， IP都会先把数据放到发送队列中，然后根据实际情况再考虑是不是立刻发送。

而我们大部分情况下，都不会用  `MSG_MORE`，也就是来一个数据包就直接发一个数据包。从这个行为上来说，**虽然UDP用上了发送缓冲区，但实际上并没有起到"缓冲"的作用。**

#### Nagle算法

Nagle算法同Delay ACK的目的一样，减少小报文的传输，增加网络效率

Nagle的伪代码

```c
if 有数据要发送 { 
	if 可用窗口大小 >= MSS and 可发送的数据 >= MSS 
		{ 立刻发送MSS大小的数据 } 
	else 
	{ 
		if 有未确认的数据 
			{ 将数据放入缓存等待接收ACK } 
		else { 立刻发送数据 } 
	} 
}
```

使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才能可以发送数据： 

- 条件一：要等到窗口大小 >= MSS 并且 数据大小 >= MSS；
- 条件二：收到之前发送数据的 ack 回包； 

只要上面两个条件都不满足，发送方一直在囤积数据，直到满足上面的发送条件。

另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。

可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）。



Delay ACK 和 Nagle 算法混合使用时，会产生新的问题

这两个方法看似都能解决一些问题。但是如果一起用就很糟糕了。

假设客户端打开了 Nagle’s Algorithm，服务端打开了 Delay ACK。这时候客户端要发送一个 HTTP 请求给服务端，这个HTTP 请求大于 1 MSS，要用 2 个 IP 包发送。于是情况就变成了：

- Client: 这是第一个包
- Server：… (不会发送 ACK，直到 Server 想发送数据给 Client，但是这里因为 Server 没有收到整个 HTTP 请求内容，所以 Server 不会发送数据给 Client）
- Client: … （因为 Nagle 算法，Client 在等待对方的 ACK，然后再发送第二个包的数据）
- Server: 好吧，我等够了，这是 ACK
- Client: 这是第二个包

![img](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409041938191.jpeg)

解决方法是关闭 Delay ACK 或者 Nagle’s Algorithm。

### 键入网址到网页显示，期间发生了什么？

1. 解析URL：分析 URL 所需要使用的传输协议和请求的资源路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，则对非法字符进行转义后在进行下一过程。
2. 缓存判断：浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里且没有失效，那么就直接使用；否则检查系统缓存中有没有解析过的结果，有就直接使用【浏览器缓存、系统缓存】
3. DNS解析：如果资源不在本地缓存，首先需要进行DNS解析。浏览器会向**本地DNS服务器发送域名解析请求**，本地域名服务器如果有缓存的IP地址，那么直接返回。否则，本地DNS服务器会逐级查询，最终找到对应的IP地址。
4. 获取MAC地址：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
5. 建立TCP连接：主机将使用目标 IP地址和目标MAC地址发送一个TCP SYN包，请求建立一个TCP连接，然后交给路由器转发，等路由器转到目标服务器后，服务器回复一个SYN-ACK包，确认连接请求。然后，主机发送一个ACK包，确认已收到服务器的确认，然后 TCP 连接建立完成。
6. HTTPS 的 TLS 四次握手：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的四次握手。
   1. 发送HTTP请求：连接建立后，浏览器会向服务器发送HTTP请求。请求中包含了用户需要获取的资源的信息，例如网页的URL、请求方法（GET、POST等）等。HTTP请求会被封装在TCP数据包中，然后经过网络层和数据链路层，经过交换机、路由器后逐级跳转，最后达到服务器

7. 服务器处理请求并返回响应：服务器收到数据包后，会进行拆包操作。然后会根据请求的内容进行相应的处理。例如，如果是请求网页，服务器会读取相应的网页文件，并生成HTTP响应。

### 客户端连不上服务器 怎么排查客户端出了什么问题，用什么命令

#### 1. **检查网络连接**

- 使用 `ping` 命令

  - 目标：验证客户端是否可以访问服务器的 IP 地址。

  - 命令：

    ```bash
    ping <服务器IP地址>
    ```

  - 结果分析：

    - 成功：客户端与服务器之间的基本网络连接正常。
    - 失败：可能是客户端网络配置错误、网络中断，或者防火墙阻止了 ICMP 请求。

#### 2. **使用 `telnet` 或 `nc` 测试端口**

- 使用 `telnet` 或 `nc` 命令

  - 目标：手动连接到服务器的特定端口，确认端口是否开放且可达。

  - 命令：

    ```
    telnet <服务器IP地址> <端口号>
    ```

    或

    ```
    nc -zv <服务器IP地址> <端口号>
    ```

  - 结果分析：

    - 成功：确认端口开放，连接问题可能出在应用程序本身。
    - 失败：可能是防火墙、网络问题，或服务器未监听该端口。

#### **3. 检查客户端网络配置**

- **查看网络配置**：

  - 目标：确保客户端的 IP 地址、子网掩码和网关配置正确。

  - 命令

    - Linux:

      ```bash
      ifconfig
      ```

  - 结果分析：

    - 确保 IP 地址和网关正确配置，并在同一子网中（如果适用）。

- **查看路由表**：

  - 目标：确保到达服务器的路由正确。

  - 命令：

    ```bash
    route -n
    ```

  - 结果分析：

    - 确保路由表中有指向服务器的正确路径。

#### 4. **检查防火墙设置**

- 查看防火墙规则

  - 目标：确保防火墙没有阻止客户端的出站连接。

  - 命令：

    ```
    sudo iptables -L -n
    ```

#### 5. **检查 DNS 解析**

- 使用 `nslookup` 或 `dig` 命令

  - 目标：确认客户端是否能正确解析服务器的域名。

  - 命令：

    ```bash
    nslookup <服务器域名>
    ```

  - 结果分析：

    - 成功：DNS 配置正常，能够解析服务器的 IP 地址。
    - 失败：DNS 配置错误，或者 DNS 服务器不可用。

#### **6. 检查路径连通性**

- 使用 `traceroute` 命令

  - 目标：查看客户端到服务器的路由路径，识别网络中断或高延迟的节点。

  - 命令：

    ```
    traceroute <服务器IP地址>
    ```

#### 7.**使用抓包工具**：

- 可以使用 `tcpdump`（Linux/macOS）或 `Wireshark` 抓包分析通信过程中发生了什么：

- ```bash
  sudo tcpdump -i eth0 tcp and host 192.168.1.20 and port 80 -w capture.pcap
  ```

  ### 命令说明：

  - `sudo`：以超级用户权限运行 `tcpdump`，因为捕获网络流量通常需要管理员权限。
  - `tcpdump`：启动 `tcpdump` 工具。
  - `-i eth0`：指定要捕获流量的网络接口，这里使用 `eth0` 作为示例。你可以用 `ifconfig` 或 `ip a` 命令查看你的实际网络接口名称。
  - `tcp`：只捕获TCP协议的数据包。
  - `and host 192.168.1.20`：过滤条件，表示只捕获与服务器IP地址 `192.168.1.20` 相关的流量。
  - `and port 80`：进一步过滤，只捕获与端口80（HTTP）相关的流量。
  - `-w capture.pcap`：将捕获的数据包保存到文件 `capture.pcap` 中，以便后续使用Wireshark或其他分析工具进行详细分析。

  - **三次握手**

    如果只看到客户端发送了SYN包，但没有看到服务器的SYN-ACK响应，可能是服务器没有收到请求或服务器防火墙阻止了响应。

## IP层

### 网络层与数据链路层有什么关系呢？

IP 的作用是主机之间通信用的，而 MAC 的作用则是**实现「直连」的两个设备之间通信**，而 IP 则**负责在「没有直连」的两个网络之间进行通信传输**。

**IP地址**在网络层用于确定数据包的目标主机，**决定数据包的目的地是哪一个子网**。

**MAC地址**在数据链路层用于在**同一物理网络或局域网**中传输数据，**确保数据帧在具体的物理链路上传递到目标设备**。

![IP 的作用与 MAC 的作用](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202410141642369.png)

### ip地址的分类

IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。

![IP 地址分类](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202410141644340.png)

**A、B、C 分类地址最大主机个数是如何计算的呢？**

最大主机个数，就是要看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最大主机个数：

共$2^8 - 2$个，为什么需要减2，因为在IP地址中，有两个IP地址是特殊的，分别是主机号为全0和全1

主机号全1指定某个网络下的所有主机，用于广播

主机号全0**用于表示整个网络/子网**。

这两个IP地址需要去掉

### 无分类地址 CIDR

正因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 CIDR。 

这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。

**怎么划分网络号和主机号的呢？**

1. 表示形式 a.b.c.d/x，其中 /x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。

2. 还有另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。子网掩码除了可以划分网络号和主机号，还可以进行子网的划分

### IP头部

![IPv4 首部与 IPv6 首部的差异](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409262106578.png)

**版本号（Version）**：长度4bit，标识目前采用的IP协议的版本号，一般的值0100（IPv4），0110（IPv6）

**首部长度（Header Length）**：长度4bit，这个字段的作用是为了描述IP头部的长度，IP头部长度是可变的

**生存期（TTL：Time to Live）字段**：是 IP 数据报可以经过的最大路由数，占8比特，限制IP数据包在计算机网络中的存在的时间，即数据包可以经过的路由器数，每经过一个路由器，TTL减去1，当它为0时，则该数据报被丢弃。

**协议（Protocol）**：长度8bit，标识了上层所使用的协议，以下是比较常用的协议号：

| 1    | ICMP |
| ---- | ---- |
| 2    | IGMP |
| 6    | TCP  |
| 17   | UDP  |
| 88   | IGRP |
| 89   | OSPF |

### IP 地址与路由控制

IP地址的网络地址这一部分是用于进行路由控制。 

路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。 

在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。 

下面以下图的网络链路作为例子说明：

![IP 地址与路由控制](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202410141723499.png)

### ping的工作原理

ping是基于ICMP协议，互联网控制报文协议

ICMP的功能：**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。**

> ICMP 包头格式

ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。

![ICMP 报文](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409051517611.png)

ICMP 包头的类型字段，大致可以分为两大类： 

1. 一类是用于诊断的查询消息，也就是「查询报文类型」 
2. 另一类是通知出错原因的错误消息，也就是「差错报文类型」

![常见的 ICMP 类型](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409051518316.png)

### ping —— 查询报文类型的使用

ping的**发送和接收过程**，A执行pingB后，发生了什么？

ICMP 数据包内包含多个字段，最重要的是两个： 

- 第一个是类型，对于回送请求消息而言该字段为 8； 
- 另外一个是序号，主要用于区分连续 ping 的时候发出的多个数据包。 

每发出一个请求数据包，序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。

后续加上IP和MAC头

主机B收到数据帧后，检查MAC地址，然后交给IP协议，IP协议检查后，交给ICMP协议。

主机B会构建一个回送响应消息数据包，类型为0，序号为1，加上发送时间，然后包装头部后发送给A

### 断网了，还能ping通127.0.0.1吗？

答案：可以ping通

#### 什么是127.0.0.1

127.0.0.1是IPV4的回环地址，::0（0:0:0:0:0:0:0:1）是IPV6的回环地址

#### 为什么断网了还能 ping 通 127.0.0.1

前面提到，有网的情况下，ping 最后是通过网卡将数据发送出去的。 

那么断网的情况下，网卡已经不工作了，ping 回环地址却一切正常，我们可以看下这种情况下的工作原理。

![图片](https://jiejiesks.oss-cn-beijing.aliyuncs.com/Note/202409051531323.png)

从应用层到传输层再到网络层。这段路径跟ping外网的时候是几乎是一样的。到了网络层，系统会根据目的IP，在路由表中获取对应的路由信息，而这其中就包含选择哪个网卡把消息发出。

当发现目标IP是外网IP时，会从"真网卡"发出。 

当发现目标IP是回环地址时，就会选择本地网卡。 

本地网卡，其实就是个**"假网卡"，它不像"真网卡"那样有个ring buffer什么的，"假网卡"会把数据推到一个叫 input_pkt_queue 的 链表 中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个软中断**。 

专门处理软中断的工具人**"ksoftirqd"** （这是个内核线程），它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。
**ping回环地址和ping本机地址没有区别**。

#### 127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗

首先 localhost 就不叫 IP，它是一个域名，就跟 "baidu.com",是一个形式的东西，只不过默认会把它解析为 127.0.0.1 ，当然这可以在 /etc/hosts 文件下进行修改。 

所以默认情况下，使用 localhost 跟使用 127.0.0.1 确实是没区别的。 

其次就是 0.0.0.0，执行 ping 0.0.0.0 ，是会失败的，因为它在IPV4中表示的是无效的目标地址。

但它还是很有用处的，回想下，我们启动服务器的时候，一般会 listen 一个 IP 和端口，等待客户端的连接。 

如果此时 listen 的是本机的 0.0.0.0 , 那么它表示表示本机上的任意IPV4地址（公网IP、内网IP）



